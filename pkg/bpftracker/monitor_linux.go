package bpftracker

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/balajiv113/trackport/pkg/trackapi"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/sirupsen/logrus"
	"github.com/vishvananda/netns"
	"net"
	"syscall"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type event bpf fentry.c -- -I./headers
type EbpfPortTracker struct {
	trackapi.PortTracker
	callbackFn func(event *trackapi.PortEvent)
}

func NewTracker(callbackFn func(event *trackapi.PortEvent)) trackapi.PortTracker {
	return &EbpfPortTracker{callbackFn: callbackFn}
}

func (m *EbpfPortTracker) Run(ctx context.Context) error {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		return err
	}

	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		return err
	}
	defer objs.Close()

	tcpPgms := []*ebpf.Program{
		objs.bpfPrograms.InetCskAccept,
		objs.bpfPrograms.InetCskListenStop,
	}
	udpPgms := []*ebpf.Program{
		objs.bpfPrograms.InetBindSk,
		objs.bpfPrograms.Inet6BindSk,
		objs.bpfPrograms.UdpDestroySock,
		objs.bpfPrograms.Udpv6DestroySock,
	}

	links := make([]link.Link, 10)
	for _, pgm := range tcpPgms {
		traceLink, err := link.AttachTracing(link.TracingOptions{
			Program: pgm,
		})
		if err != nil {
			return err
		}
		links = append(links, traceLink)
	}

	for _, pgm := range udpPgms {
		traceLink, err := link.AttachTracing(link.TracingOptions{
			Program: pgm,
		})
		if err != nil {
			return err
		}
		links = append(links, traceLink)
	}

	defer func() {
		for _, traceLink := range links {
			traceLink.Close()
		}
	}()

	pidNs := make(map[int]string)
	ns, _ := netns.Get()
	uniqueId := ns.UniqueId()

	rd, err := ringbuf.NewReader(objs.bpfMaps.Events)
	if err != nil {
		return err
	}
	defer rd.Close()

	// bpfEvent is generated by bpf2go.
	var event bpfEvent
	for {
		if ctx.Err() != nil {
			return nil
		}
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				logrus.Errorf("received signal, exiting..")
				return nil
			}
			logrus.Errorf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
			logrus.Errorf("parsing ringbuf event: %s", err)
			continue
		}

		eventNs, err := netns.GetFromPid(int(event.Pid))
		eventId := eventNs.UniqueId()
		if eventNs == -1 {
			eventId = pidNs[int(event.Pid)]
		}
		if uniqueId == eventId {
			pidNs[int(event.Pid)] = eventId
			ip := convertArrayToIP(event.Saddr, event.Family == syscall.AF_INET6)
			port := fmt.Sprintf("%d", event.Sport)
			m.callbackFn(&trackapi.PortEvent{Action: event.Action, Protocol: event.Proto, Ip: ip, Port: port})
			if event.Action != trackapi.CLOSE {
				continue
			}
		}
		delete(pidNs, int(event.Pid))
	}
}

// convertArrayToIP converts an array of uint32 values to a net.IP address.
func convertArrayToIP(input [4]uint32, ipv6 bool) net.IP {
	if ipv6 {
		addressBuf := make(net.IP, 16)
		for i := range 4 {
			binary.BigEndian.PutUint32(addressBuf[i*4:i*4+4], input[i])
		}
		return addressBuf
	} else {
		addressBuf := make(net.IP, 4)
		binary.BigEndian.PutUint32(addressBuf, input[0])
		return addressBuf
	}
}
