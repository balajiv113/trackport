package trackport

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/sirupsen/logrus"
	"github.com/vishvananda/netns"
	"net"
	"syscall"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type event bpf fentry.c -- -I./headers

type PortTracker struct {
	tcp bool
	udp bool

	callbackFn func(event *PortEvent)
}

type (
	Protocol = uint16
	Action   = uint16
)

const (
	TCP Protocol = iota
	UDP
)

const (
	OPEN Action = iota
	CLOSE
)

func ProtocolToString(protocol Protocol) string {
	switch protocol {
	case UDP:
		return "udp"
	default:
		return "tcp"
	}
}

type PortEvent struct {
	Protocol Protocol
	Action   Action
	Ip       net.IP
	Port     string
}

func NewTracker(callbackFn func(event *PortEvent), udp bool) *PortTracker {
	return &PortTracker{callbackFn: callbackFn, tcp: true, udp: udp}
}

func (m *PortTracker) Run(ctx context.Context) error {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		return err
	}

	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		return err
	}
	defer objs.Close()

	tcpPgms := []*ebpf.Program{
		objs.bpfPrograms.InetCskAccept,
		objs.bpfPrograms.InetCskListenStop,
	}
	udpPgms := []*ebpf.Program{
		objs.bpfPrograms.InetBindSk,
		objs.bpfPrograms.Inet6BindSk,
		objs.bpfPrograms.UdpDestroySock,
		objs.bpfPrograms.Udpv6DestroySock,
	}

	links := make([]link.Link, 10)
	if m.tcp {
		for _, pgm := range tcpPgms {
			traceLink, err := link.AttachTracing(link.TracingOptions{
				Program: pgm,
			})
			if err != nil {
				return err
			}
			links = append(links, traceLink)
		}
	}

	if m.udp {
		for _, pgm := range udpPgms {
			traceLink, err := link.AttachTracing(link.TracingOptions{
				Program: pgm,
			})
			if err != nil {
				return err
			}
			links = append(links, traceLink)
		}
	}

	defer func() {
		for _, traceLink := range links {
			traceLink.Close()
		}
	}()

	pidNs := make(map[int]string)
	ns, _ := netns.Get()
	uniqueId := ns.UniqueId()

	rd, err := ringbuf.NewReader(objs.bpfMaps.Events)
	if err != nil {
		return err
	}
	defer rd.Close()

	// bpfEvent is generated by bpf2go.
	var event bpfEvent
	for {
		if ctx.Err() != nil {
			return nil
		}
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				logrus.Errorf("received signal, exiting..")
				return nil
			}
			logrus.Errorf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
			logrus.Errorf("parsing ringbuf event: %s", err)
			continue
		}

		eventNs, err := netns.GetFromPid(int(event.Pid))
		eventId := eventNs.UniqueId()
		if eventNs == -1 {
			eventId = pidNs[int(event.Pid)]
		}
		if uniqueId == eventId {
			pidNs[int(event.Pid)] = eventId
			ip := convertArrayToIP(event.Saddr, event.Family == syscall.AF_INET6)
			port := fmt.Sprintf("%d", event.Sport)
			m.callbackFn(&PortEvent{Action: event.Action, Protocol: event.Proto, Ip: ip, Port: port})
			if event.Action != CLOSE {
				continue
			}
		}
		delete(pidNs, int(event.Pid))
	}
}

// convertArrayToIP converts an array of uint32 values to a net.IP address.
func convertArrayToIP(input [4]uint32, ipv6 bool) net.IP {
	if ipv6 {
		addressBuf := make(net.IP, 16)
		for i := range 4 {
			binary.BigEndian.PutUint32(addressBuf[i*4:i*4+4], input[i])
		}
		return addressBuf
	} else {
		addressBuf := make(net.IP, 4)
		binary.BigEndian.PutUint32(addressBuf, input[0])
		return addressBuf
	}
}
